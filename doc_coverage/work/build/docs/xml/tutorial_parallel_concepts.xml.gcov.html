<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 5cafbabf779d8986d44a5fc730ab24cde7fafd16 - /work/build/docs/xml/tutorial_parallel_concepts.xml</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title"> SpECTRE Documentation Coverage Report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">work/build/docs/xml</a> - tutorial_parallel_concepts.xml</td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
             <td class="headerItem">Commit:</td>
             <td class="headerValue"><a target="_blank" href="https://github.com/sxs-collaboration/spectre/commit/5cafbabf779d8986d44a5fc730ab24cde7fafd16">5cafbabf779d8986d44a5fc730ab24cde7fafd16</a></td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-05-06 03:25:12</td>
            <td></td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<span class="lineNum">       1 </span><span class="lineCov">          1 : &lt;?xml version='1.0' encoding='UTF-8' standalone='no'?&gt;</span>
<span class="lineNum">       2 </span>            : &lt;doxygen xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;compound.xsd&quot; version=&quot;1.8.13&quot;&gt;
<span class="lineNum">       3 </span>            :   &lt;compounddef id=&quot;tutorial_parallel_concepts&quot; kind=&quot;page&quot;&gt;
<span class="lineNum">       4 </span>            :     &lt;compoundname&gt;tutorial_parallel_concepts&lt;/compoundname&gt;
<span class="lineNum">       5 </span>            :     &lt;title&gt;Parallelization in SpECTRE&lt;/title&gt;
<span class="lineNum">       6 </span>            :     &lt;detaileddescription&gt;
<span class="lineNum">       7 </span>            : &lt;para&gt;This overview describes the concepts and terminology that SpECTRE uses to enable parallelism. This overview is a general discussion with no code examples. Subsequent tutorials will provide a more in-depth exploration of the parallelization infrastructure, including code examples.&lt;/para&gt;&lt;para&gt;Unlike many parallel scientific codes which use data-based parallelism, SpECTRE uses task-based parallelism. The classical strategy for parallelism (data-based parallelism) is to assign a portion of the data to processes (or threads) that synchronously execute compute kernels. This is implemented in many codes but it is difficult to design codes with this strategy that will efficiently scale for complex multi-scale, multi-physics workloads. Task-based parallelism provides a solution: Instead of dividing work between parallel processes based on data ownership, there is a set of tasks and their inter-dependencies. Tasks are scheduled and assigned to processes dynamically, providing opportunities for load balancing and minimization of idle threads. By dividing the program into small enough tasks such that you have several tasks per thread, communication time is hidden by interleaving tasks that are ready to be executed with tasks that are waiting for data.&lt;/para&gt;&lt;para&gt;In order to implement task-based parallelism, SpECTRE is built on top of the parallel programming framework of the Charm++ library, which is developed by the &lt;ulink url=&quot;http://charm.cs.illinois.edu/&quot;&gt;Parallel Programming Laboratory&lt;/ulink&gt; at the University of Illinois. Charm++ is a mature parallel programming framework that provides intra-node threading and can use a variety of communication interfaces (including MPI) to communicate between nodes. Charm++ has a large user base, which includes users of the cosmological &lt;formula id=&quot;103&quot;&gt;$N$&lt;/formula&gt;-body code &lt;ulink url=&quot;https://github.com/N-BodyShop/changa/wiki/ChaNGa&quot;&gt;ChaNGa&lt;/ulink&gt; and of the molecular dynamics code &lt;ulink url=&quot;https://www.ks.uiuc.edu/Research/namd/&quot;&gt;NAMD&lt;/ulink&gt;.&lt;/para&gt;&lt;para&gt;&lt;heading level=&quot;2&quot;&gt;Charm++ basic concepts&lt;/heading&gt;
<span class="lineNum">       8 </span>            : &lt;/para&gt;&lt;para&gt;In order to understand how parallelization works in SpECTRE, it is useful to understand the basic concepts in the design of Charm++. Much of the following is quoted verbatim from the &lt;ulink url=&quot;https://charm.readthedocs.io&quot;&gt;Charm++ documentation&lt;/ulink&gt;, interspersed with comments on how SpECTRE interacts with Charm++.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;Charm++ is a C++-based parallel programming system, founded on the migratable-objects programming model, and supported by a novel and powerful adaptive runtime system. It supports both irregular as well as regular applications, and can be used to specify task-parallelism as well as data parallelism in a single application. It automates dynamic load balancing for task-parallel as well as data-parallel applications, via separate suites of load-balancing strategies. Via its message-driven execution model, it supports automatic latency tolerance, modularity and parallel composition. Charm++ also supports automatic checkpoint/restart, as well as fault tolerance based on distributed checkpoints. &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;SpECTRE currently wraps only some of the features of Charm++, primarily the ones that support task-parallelism. We are just beginning our exploration of dynamic load balancing. Coming soon we will utilize automatic checkpoint/restart. At present we do not use Charm++ support for fault tolerance.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;The key feature of the migratable-objects programming model is over-decomposition: The programmer decomposes the program into a large number of work units and data units, and specifies the computation in terms of creation of and interactions between these units, without any direct reference to the processor on which any unit resides. This empowers the runtime system to assign units to processors, and to change the assignment at runtime as necessary. &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;SpECTRE&amp;apos;s parallelization module is designed to make it easy for users to exploit the migratable-object model by providing a framework to define the units into which a program can be decomposed.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;A basic unit of parallel computation in Charm++ programs is a chare. At its most basic level, it is just a C++ object. A Charm++ computation consists of a large number of chares distributed on available processors of the system, and interacting with each other via asynchronous method invocations. Asynchronously invoking a method on a remote object can also be thought of as sending a “message” to it. So, these method invocations are sometimes referred to as messages. (besides, in the implementation, the method invocations are packaged as messages anyway). Chares can be created dynamically. &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;In SpECTRE, we wrap Charm++ chares in struct templates that we call &lt;bold&gt;parallel components&lt;/bold&gt; that represent a collection of distributed objects. We wrap the asynchronous method invocations between the elements of parallel components in struct templates that we call &lt;bold&gt;actions&lt;/bold&gt;. Thus, each element of a parallel component can be thought of as a C++ object that exists on one core on the supercomputer, and an action as calling a member function of that object, even if the caller is on another core.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;Conceptually, the system maintains a “work-pool” consisting of seeds for new chares, and messages for existing chares. The Charm++ runtime system (Charm RTS) may pick multiple items, non-deterministically, from this pool and execute them, with the proviso that two different methods cannot be simultaneously executing on the same chare object (say, on different processors). Although one can define a reasonable theoretical operational semantics of Charm++ in this fashion, a more practical description of execution is useful to understand Charm++. A Charm++ application’s execution is distributed among Processing Elements (PEs), which are OS threads or processes depending on the selected Charm++ build options. On each PE, there is a scheduler operating with its own private pool of messages. Each instantiated chare has one PE which is where it currently resides. The pool on each PE includes messages meant for chares residing on that PE, and seeds for new chares that are tentatively meant to be instantiated on that PE. The scheduler picks a message, creates a new chare if the message is a seed (i.e. a constructor invocation) for a new chare, and invokes the method specified by the message. When the method returns control back to the scheduler, it repeats the cycle (i.e. there is no pre-emptive scheduling of other invocations). &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;It is very important to keep in mind that the actions that are executed on elements of parallel components are done so non-deterministically by the run-time system. Therefore it is the responsibility of the programmer to ensure that actions are not called out of order. This means that if action B must be executed after action A on a given element of a parallel component, the programmer must ensure that either action B is called after the completion of action A (i.e. it is not sufficient that action B is invoked after action A is invoked), or that a &lt;computeroutput&gt;is_ready&lt;/computeroutput&gt; function of action B only succeeds if action A has been completed.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;When a chare method executes, it may create method invocations for other chares. The Charm Runtime System (RTS) locates the PE where the targeted chare resides, and delivers the invocation to the scheduler on that PE. &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;In SpECTRE, this is done by one element of a parallel component calling an action on an element of a another parallel component.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;Methods of a chare that can be remotely invoked are called entry methods. Entry methods may take serializable parameters, or a pointer to a message object. Since chares can be created on remote processors, obviously some constructor of a chare needs to be an entry method. Ordinary entry methods are completely non-preemptive- Charm++ will not interrupt an executing method to start any other work, and all calls made are asynchronous. &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;In SpECTRE, the struct template that defines a parallel component has taken care of creating the entry methods for the underlying chare, which are then called by invoking actions.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;Charm++ provides dynamic seed-based load balancing. Thus location (processor number) need not be specified while creating a remote chare. The Charm RTS will then place the remote chare on a suitable processor. Thus one can imagine chare creation as generating only a seed for the new chare, which may take root on some specific processor at a later time. &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;We are just in the process of beginning to explore the load-balancing features of Charm++, but plan to have new elements of parallel components (the wrapped chares) be creatable using actions, without specifying the location on which the new element is created.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;Chares can be grouped into collections. The types of collections of chares supported in Charm++ are: chare-arrays, chare-groups, and chare-nodegroups, referred to as arrays, groups, and nodegroups throughout this manual for brevity. A Chare-array is a collection of an arbitrary number of migratable chares, indexed by some index type, and mapped to processors according to a user-defined map group. A group (nodegroup) is a collection of chares, with exactly one member element on each PE (“node”). &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;Each of SpECTRE&amp;apos;s parallel components has a type alias &lt;computeroutput&gt;chare_type&lt;/computeroutput&gt; corresponding to whether it is a chare-array, chare-group, or chare-nodegroup. In addition we support a singleton which is essentially a one-element array.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;Charm++ does not allow global variables, except readonly variables. A chare can normally only access its own data directly. However, each chare is accessible by a globally valid name. So, one can think of Charm++ as supporting a global object space. &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;SpECTRE does not use the readonly global variables provided by Charm++. Instead SpECTRE provides a nodegroup called the &lt;computeroutput&gt;ConstGlobalCache&lt;/computeroutput&gt; which provides global access to read-only objects, as well as a way to access every parallel component.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;Every Charm++ program must have at least one mainchare. Each mainchare is created by the system on processor 0 when the Charm++ program starts up. Execution of a Charm++ program begins with the Charm RTS constructing all the designated mainchares. For a mainchare named X, execution starts at constructor X() or X(CkArgMsg *) which are equivalent. Typically, the mainchare constructor starts the computation by creating arrays, other chares, and groups. It can also be used to initialize shared readonly objects. &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;SpECTRE provides a pre-defined mainchare called &lt;computeroutput&gt;Main&lt;/computeroutput&gt; that is run when a SpECTRE executable is started. &lt;computeroutput&gt;Main&lt;/computeroutput&gt; will create the other parallel components, and initialize items in the &lt;computeroutput&gt;ConstGlobalCache&lt;/computeroutput&gt; whose items can be used by any parallel component.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;Charm++ program execution is terminated by the CkExit call. Like the exit system call, CkExit never returns, and it optionally accepts an integer value to specify the exit code that is returned to the calling shell. If no exit code is specified, a value of zero (indicating successful execution) is returned. The Charm RTS ensures that no more messages are processed and no entry methods are called after a CkExit. CkExit need not be called on all processors; it is enough to call it from just one processor at the end of the computation. &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;SpECTRE wraps &lt;computeroutput&gt;CkExit&lt;/computeroutput&gt; with the function &lt;computeroutput&gt;&lt;ref refid=&quot;group__ParallelGroup_1ga8ca2773484152df4d8897024a244b3c0&quot; kindref=&quot;member&quot;&gt;Parallel::exit&lt;/ref&gt;&lt;/computeroutput&gt;. As no more messages are processed by Charm++ after this call, SpECTRE also defines a special &lt;computeroutput&gt;Exit&lt;/computeroutput&gt; phase that is guaranteed to be executed after all messages and entry methods have been processed.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;As described so far, the execution of individual Chares is “reactive”: When method A is invoked the chare executes this code, and so on. But very often, chares have specific life-cycles, and the sequence of entry methods they execute can be specified in a structured manner, while allowing for some localized non-determinism (e.g. a pair of methods may execute in any order, but when they both finish, the execution continues in a pre-determined manner, say executing a 3rd entry method). &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;Charm++ provides a special notation to simplify expression of such control structures, but this requires writing specialized interface files that are parsed by Charm++. SpECTRE does not support this; rather we split the executable into a set of user-defined phases. In each phase, each parallel component will execute a user-defined list of actions.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;The normal entry methods, being asynchronous, are not allowed to return any value, and are declared with a void return type. &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;SpECTRE&amp;apos;s actions do not return any value to the calling component. Instead when the action is finished it can call another action to send data to an element of any parallel component.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;To support asynchronous method invocation and global object space, the RTS needs to be able to serialize (“marshall”) the parameters, and be able to generate global “names” for chares. For this purpose, programmers have to declare the chare classes and the signature of their entry methods in a special “.ci” file, called an interface file. Other than the interface file, the rest of a Charm++ program consists of just normal C++ code. The system generates several classes based on the declarations in the interface file, including “Proxy” classes for each chare class. Those familiar with various component models (such as CORBA) in the distributed computing world will recognize “proxy” to be a dummy, standin entity that refers to an actual entity. For each chare type, a “proxy” class exists. The methods of this “proxy” class correspond to the remote methods of the actual class, and act as “forwarders”. That is, when one invokes a method on a proxy to a remote object, the proxy marshalls the parameters into a message, puts adequate information about the target chare on the envelope of the message, and forwards it to the remote object. Individual chares, chare array, groups, node-groups, as well as the individual elements of these collections have a such a proxy. Multiple methods for obtaining such proxies are described in the manual. Proxies for each type of entity in Charm++ have some differences among the features they support, but the basic syntax and semantics remain the same - that of invoking methods on the remote object by invoking methods on proxies. &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;SpECTRE has wrapped all of this functionality in order to make it easier to use. SpECTRE automatically creates the interface files for each parallel component using template metaprogramming. SpECTRE provides proxies for each parallel component that are all held in the &lt;computeroutput&gt;ConstGlobalCache&lt;/computeroutput&gt; which is available to every parallel component. In order for actions to be called as entry methods on remote parallel components, the arguments to the function call must be serializable. Charm++ provides the &lt;computeroutput&gt;PUP&lt;/computeroutput&gt; framework to serialize objects where &lt;computeroutput&gt;PUP&lt;/computeroutput&gt; stands for pack-unpack. Since the PUP framework is used by Charm++ for checkpointing, load-balancing, and passing arguments when calling actions, all user-defined classes with member data must define a &lt;computeroutput&gt;pup&lt;/computeroutput&gt; function.&lt;/para&gt;&lt;para&gt;&lt;blockquote&gt;&lt;para&gt;In terms of physical resources, we assume the parallel machine consists of one or more nodes, where a node is a largest unit over which cache coherent shared memory is feasible (and therefore, the maximal set of cores per which a single process can run. Each node may include one or more processor chips, with shared or private caches between them. Each chip may contain multiple cores, and each core may support multiple hardware threads (SMT for example). Charm++ recognizes two logical entities: a PE (processing element) and a logical node, or simply “node”. In a Charm++ program, a PE is a unit of mapping and scheduling: each PE has a scheduler with an associated pool of messages. Each chare is assumed to reside on one PE at a time. A logical node is implemented as an OS process. In non-SMP mode there is no distinction between a PE and a logical node. Otherwise, a PE takes the form of an OS thread, and a logical node may contain one or more PEs. Physical nodes may be partitioned into one or more logical nodes. Since PEs within a logical node share the same memory address space, the Charm++ runtime system optimizes communication between them by using shared memory. Depending on the runtime command-line parameters, a PE may optionally be associated with a subset of cores or hardware threads. &lt;/para&gt;&lt;/blockquote&gt;&lt;/para&gt;&lt;para&gt;In other words, how Charm++ defines a node and a PE depends upon how Charm++ was installed on a system. The executable &lt;computeroutput&gt;Executables/ParallelInfo&lt;/computeroutput&gt; can be used to determine how many nodes and PEs exist for a given Charm++ build and the runtime command-line parameters passed when calling the executable.&lt;/para&gt;&lt;para&gt;For more details see the &lt;ulink url=&quot;https://charm.readthedocs.io&quot;&gt;Charm++ documentation&lt;/ulink&gt; and &lt;ref refid=&quot;dev_guide_parallelization_foundations&quot; kindref=&quot;compound&quot;&gt;Parallization, Charm++, and Core Concepts&lt;/ref&gt;. &lt;/para&gt;    &lt;/detaileddescription&gt;
<span class="lineNum">       9 </span>            :   &lt;/compounddef&gt;
<span class="lineNum">      10 </span>            : &lt;/doxygen&gt;
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

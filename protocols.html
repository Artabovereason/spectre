<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.13"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Protocols</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="popper.min.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="index.html">
      SpECTRE &#160;
        <span id="projectnumber">v0.0.0</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Introduction</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="installation.html">
              <i class="octicon octicon-desktop-download"></i><span>Installation</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>User Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="code_of_conduct.html">
              <i class="octicon octicon-comment-discussion"></i><span>Code of Conduct</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="contributing_to_spectre.html">
              <i class="octicon octicon-git-pull-request"></i><span>Contributing Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Code Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Topics</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <li>
        <a href="citelist.html">
          <i class="octicon octicon-file-text"></i><span>Bibliography</span>
        </a>
      </li>
      <li>
        <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
          <i class="octicon octicon-mark-github"></i><span>View on GitHub</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Protocols </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#protocols_overview">Overview of protocols</a></li>
<li class="level1"><a href="#protocols_testing_conformance">Protocol users: Testing protocol conformance</a></li>
<li class="level1"><a href="#protocols_author">Protocol authors: Protocols must be unary type traits</a></li>
<li class="level1"><a href="#protocols_testing">Protocol authors: Testing a protocol</a></li>
<li class="level1"><a href="#protocols_and_constraints">Protocols and C++20 &quot;Constraints and concepts&quot;</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="protocols_overview"></a>
Overview of protocols</h1>
<p>Protocols are a concept we use in SpECTRE to define metaprogramming interfaces. A variation of this concept is built into many languages, so this is a quote from the <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html">Swift documentation</a>:</p>
<blockquote class="doxtable">
<p>A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to conform to that protocol. </p>
</blockquote>
<p>You should define a protocol when you need a template parameter to conform to an interface. Protocols are implemented as unary type traits. Here is an example of a protocol that is adapted from the <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html">Swift documentation</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>protocols {</div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacedetail.html">detail</a> {</div><div class="line"><a class="code" href="group__TypeTraitsGroup.html#gaf5157dbd846dba6c52f75619eb95389f">CREATE_IS_CALLABLE</a>(name)</div><div class="line">}  <span class="comment">// namespace detail</span><span class="comment"></span></div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> * \brief Has a name.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Requires the class has these member functions:</span></div><div class="line"><span class="comment"> * - `name`: Returns the name of the object as a `std::string`.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConformingType&gt;</div><div class="line"><span class="keyword">using</span> Named = detail::is_name_callable_r&lt;std::string, ConformingType&gt;;</div><div class="line">}  <span class="comment">// namespace protocols</span></div></div><!-- fragment --><p> The protocol defines an interface that any type that adopts it must implement. For example, the following class conforms to the protocol we just defined:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Person : <span class="keyword">public</span> <a class="code" href="structtt_1_1ConformsTo.html">tt::ConformsTo</a>&lt;protocols::Named&gt; {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Function required to conform to the protocol</span></div><div class="line">  <a class="codeRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> first_name_ + <span class="stringliteral">&quot; &quot;</span> + last_name_; }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Implementation details of the class that are irrelevant to the protocol</span></div><div class="line">  <a class="codeRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> first_name_;</div><div class="line">  <a class="codeRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> last_name_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Person(<a class="codeRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> first_name, <a class="codeRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> last_name)</div><div class="line">      : first_name_(<a class="code" href="namespacestd.html">std</a>::move(first_name)), last_name_(<a class="code" href="namespacestd.html">std</a>::move(last_name)) {}</div><div class="line">};</div></div><!-- fragment --><p> The class indicates it conforms to the protocol by (publicly) inheriting from <code><a class="el" href="structtt_1_1ConformsTo.html" title="Indicate a class conforms to the Protocol. ">tt::ConformsTo</a>&lt;TheProtocol&gt;</code>.</p>
<p>Once you have defined a protocol, you can check if a class conforms to it using the <code><a class="el" href="group__ProtocolsGroup.html#ga69cadf7e1af796b7b303137ffde2f8ad" title="Checks if the ConformingType conforms to the Protocol. ">tt::conforms_to</a></code> metafunction:</p>
<div class="fragment"><div class="line">static_assert(tt::conforms_to_v&lt;Person, protocols::Named&gt;,</div><div class="line">              <span class="stringliteral">&quot;The class does not conform to the protocol.&quot;</span>);</div></div><!-- fragment --><p> Note that checking for protocol conformance is cheap, because the <code><a class="el" href="group__ProtocolsGroup.html#ga69cadf7e1af796b7b303137ffde2f8ad" title="Checks if the ConformingType conforms to the Protocol. ">tt::conforms_to</a></code> metafunction only checks if the class <em>indicates</em> it conforms to the protocol via the above inheritance. The rigorous test whether the class actually fullfills all of the protocol's requirements is deferred to its unit tests (see <a class="el" href="protocols.html#protocols_testing_conformance">Protocol users: Testing protocol conformance</a>). Therefore you may freely use protocol conformance checks in your code.</p>
<p>This is how you can write code that relies on the interface defined by the protocol:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NamedThing&gt;</div><div class="line"><a class="codeRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> greet(<span class="keyword">const</span> NamedThing&amp; named_thing) {</div><div class="line">  <span class="comment">// Make sure the template parameter conforms to the protocol</span></div><div class="line">  static_assert(tt::conforms_to_v&lt;NamedThing, protocols::Named&gt;,</div><div class="line">                <span class="stringliteral">&quot;NamedThing must be Named.&quot;</span>);</div><div class="line">  <span class="comment">// Now we can rely on the interface that the protocol defines</span></div><div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;Hello, &quot;</span> + named_thing.name() + <span class="stringliteral">&quot;!&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p> Checking for protocol conformance here makes it clear that we are expecting a template parameter that exposes the particular interface we have defined in the protocol. Therefore, the author of the protocol and of the code that uses it has explicitly defined (and documented!) the interface they expect. And the developer who consumes the protocol by writing classes that conform to it knows exactly what needs to be implemented.</p>
<p>Note that the <code><a class="el" href="group__ProtocolsGroup.html#ga69cadf7e1af796b7b303137ffde2f8ad" title="Checks if the ConformingType conforms to the Protocol. ">tt::conforms_to</a></code> metafunction is SFINAE-friendly, so you can also use it like this:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Thing,</div><div class="line">          <a class="code" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires&lt;not tt::conforms_to_v&lt;Thing, protocols::Named&gt;</a>&gt; = <span class="keyword">nullptr</span>&gt;</div><div class="line"><a class="codeRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> greet_anything(<span class="keyword">const</span> Thing&amp; <span class="comment">/*anything*/</span>) {</div><div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;Hello!&quot;</span>;</div><div class="line">}</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NamedThing,</div><div class="line">          <a class="code" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires&lt;tt::conforms_to_v&lt;NamedThing, protocols::Named&gt;</a>&gt; = <span class="keyword">nullptr</span>&gt;</div><div class="line"><a class="codeRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> greet_anything(<span class="keyword">const</span> NamedThing&amp; named_thing) {</div><div class="line">  <span class="keywordflow">return</span> greet(named_thing);</div><div class="line">}</div></div><!-- fragment --><p> We typically define protocols in a file named <code><a class="el" href="Protocols_8hpp_source.html">Protocols.hpp</a></code> and within a <code>protocols</code> namespace, similar to how we write <a class="el" href="group__DataBoxTagsGroup.html">tags</a> in a <code>Tags.hpp</code> file and within a <code>Tags</code> namespace. The file should be placed in the directory associated with the code that depends on classes conforming to the protocols. For example, the protocol <code>Named</code> in the example above would be placed in directory that also has the <code>greet</code> function.</p>
<h1><a class="anchor" id="protocols_testing_conformance"></a>
Protocol users: Testing protocol conformance</h1>
<p>Any class that indicates it conforms to the protocol must test that it actually does using the <code>test_protocol_conformance</code> metafunction from <code>tests/Unit/ProtocolTestHelpers.hpp</code>:</p>
<div class="fragment"><div class="line">static_assert(test_protocol_conformance&lt;Person, protocols::Named&gt;,</div><div class="line">              <span class="stringliteral">&quot;Failed testing protocol conformance&quot;</span>);</div></div><!-- fragment --> <h1><a class="anchor" id="protocols_author"></a>
Protocol authors: Protocols must be unary type traits</h1>
<p>When you author a new protocol, keep in mind that protocols must be unary type traits. This means they take a single template parameter (typically named <code>ConformingType</code>) and inherit from <code><a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a></code> or <code><a class="elRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::false_type</a></code> depending on whether the <code>ConformingType</code> fullfills the protocol's requirements. Make sure to implement the protocol in a SFINAE-friendly way. You may find the macros in <code><a class="el" href="Utilities_2TypeTraits_8hpp_source.html">Utilities/TypeTraits.hpp</a></code> useful. For example, we use <code>CREATE_IS_CALLABLE</code> in the protocols above for testing the existence and return type of a member function.</p>
<p>Occasionally, you might be tempted to add additional template parameters to the protocol. In those situations, make the additional parameters part of your protocol instead. The reason for this guideline is that protocols will always be used as unary type traits when inheriting from <code><a class="el" href="structtt_1_1ConformsTo.html" title="Indicate a class conforms to the Protocol. ">tt::ConformsTo</a>&lt;Protocol&gt;</code>. Therefore, any template parameters of the protocol must also be template parameters of their conforming classes, which means the protocol can just check them.</p>
<p>For example, we could be tempted to follow this antipattern:</p>
<div class="fragment"><div class="line"><span class="comment">// Don&#39;t do this. Protocols should be _unary_ type traits.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConformingType, <span class="keyword">typename</span> NameType&gt;</div><div class="line"><span class="keyword">using</span> NamedAntipattern =</div><div class="line">    <span class="comment">// Check that the `name` function exists _and_ its return type</span></div><div class="line">    detail::is_name_callable_r&lt;NameType, ConformingType&gt;;</div></div><!-- fragment --><p> However, instead of making the protocol a non-unary template we should add a requirement to it:</p>
<div class="fragment"><div class="line"><span class="comment">// Instead, do this.</span></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacedetail.html">detail</a> {</div><div class="line"><a class="code" href="group__TypeTraitsGroup.html#gae31399fb295155dea540c3e840dfa98d">CREATE_HAS_TYPE_ALIAS</a>(NameType)</div><div class="line"><a class="code" href="group__TypeTraitsGroup.html#ga2cce0a156dfe67bbf4f2b0b96b6239d9">CREATE_HAS_TYPE_ALIAS_V</a>(NameType)</div><div class="line"><span class="comment">// Lazily evaluated so we can use `ConformingType::NameType`</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConformingType&gt;</div><div class="line"><span class="keyword">struct </span>IsNameCallableWithType</div><div class="line">    : is_name_callable_r_t&lt;typename ConformingType::NameType, ConformingType&gt; {</div><div class="line">};</div><div class="line">}  <span class="comment">// namespace detail</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConformingType&gt;</div><div class="line"><span class="keyword">using</span> NamedWithType =</div><div class="line">    <span class="comment">// First check the class has a `NameType`, then use it to check the return</span></div><div class="line">    <span class="comment">// type of the `name` function.</span></div><div class="line">    <a class="codeRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/conditional.html">std::conditional_t&lt;detail::has_NameType_v&lt;ConformingType&gt;</a>,</div><div class="line">                       detail::IsNameCallableWithType&lt;ConformingType&gt;,</div><div class="line">                       <a class="codeRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::false_type</a>&gt;;</div></div><!-- fragment --><p> Classes would need to specify the additional template parameters for any protocols they conform to anyway, if the protocols had any. So they might as well expose them:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PersonWithNameType : <a class="code" href="structtt_1_1ConformsTo.html">tt::ConformsTo</a>&lt;protocols::NamedWithType&gt; {</div><div class="line">  <span class="keyword">using</span> NameType = <a class="codeRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>;</div><div class="line">  <a class="codeRef" doxygen="/__w/spectre/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> name() <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p> This pattern also allows us to check for protocol conformance first and then add further checks about the types if we wanted to:</p>
<div class="fragment"><div class="line">static_assert(tt::conforms_to_v&lt;PersonWithNameType, protocols::NamedWithType&gt;,</div><div class="line">              <span class="stringliteral">&quot;The class does not conform to the protocol.&quot;</span>);</div><div class="line">static_assert(</div><div class="line">    std::is_same_v&lt;typename PersonWithNameType::NameType, std::string&gt;,</div><div class="line">    <span class="stringliteral">&quot;The `NameType` isn&#39;t a `std::string`!&quot;</span>);</div></div><!-- fragment --> <h1><a class="anchor" id="protocols_testing"></a>
Protocol authors: Testing a protocol</h1>
<p>We are currently testing protocol conformance as part of our unit tests, so that the global <code><a class="el" href="group__ProtocolsGroup.html#ga69cadf7e1af796b7b303137ffde2f8ad" title="Checks if the ConformingType conforms to the Protocol. ">tt::conforms_to</a></code> convenience metafunction only needs to check if a type inherits off the protocol, but doesn't need to check the protocol's (possibly fairly expensive) implementation. This is primarily to keep compile times low, and may be reconsidered when transitioning to C++ "concepts". Full protocol conformance is tested in the <code>test_protocol_conformance</code> metafunction mentioned above.</p>
<p>To make sure their protocol functions correctly, protocol authors must test its implementation in a unit test (e.g. in a <code>Test_Protocols.hpp</code>):</p>
<div class="fragment"><div class="line">static_assert(protocols::Named&lt;Person&gt;::value, <span class="stringliteral">&quot;Failed testing the protocol&quot;</span>);</div><div class="line">static_assert(not protocols::Named&lt;NotNamed&gt;::value,</div><div class="line">              <span class="stringliteral">&quot;Failed testing the protocol&quot;</span>);</div></div><!-- fragment --><p> They should make sure to test the implementation with classes that conform to the protocol, and others that don't. This means the test will always include an example implementation of a class that conforms to the protocol, and the protocol author should add it to the documentation of the protocol through a Doxygen snippet. This gives users a convenient way to see how the author intends their interface to be implemented.</p>
<h1><a class="anchor" id="protocols_and_constraints"></a>
Protocols and C++20 "Constraints and concepts"</h1>
<p>A feature related to protocols is in C++20 and goes under the name of <a href="https://en.cppreference.com/w/cpp/language/constraints">constraints and concepts</a>. Every protocol defines a <em>concept</em>, but it defers checking its requirements to the unit tests to save compile time. In other words, protocols provide a way to <em>indicate</em> that a class fulfills a set of requirements, whereas C++20 constraints provide a way to <em>check</em> that a class fulfills a set of requirements. Therefore, the two features complement each other. Once C++20 becomes available in SpECTRE we can either gradually convert our protocols to concepts and use them as constraints directly if we find the impact on compile time negligible, or we can add a concept that checks protocol conformance the same way that <code><a class="el" href="group__ProtocolsGroup.html#ga4660233574869d3b757e06ecf3ec83ca" title="Checks if the ConformingType conforms to the Protocol. ">tt::conforms_to_v</a></code> currently does (i.e. by checking inheritance). </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017 - 2020
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
